'''
This script process a sample generated by DTNSIM and and computes plots for the followings metrics:
    -> Received Bundles in total
    -> Bundles Rerouted in total (amount of times that nodes re-route bundles)
    -> Hop counts in total (amount of hops that deliver bundles do in their path to destination)

All metrics will be ploted vs proportion of deleted contacts.

Arguments
    -> repetitions: Amount of repetitions for each contact plan. If for a contact plan there aren't more than one runs
                    it should be setted to 1.
    -> deletedContact: Maximun number of deleted contact. Input data must be contain a file for each case in [0
                       to deletedContact].

    -> INPUT_PATH: Path to folder that contains input files.
    -> OUTPUT_PATH: Path to folder in which script will write results.

Also, there is the following convention for input files (stored in INPUT_PATH/):

    dtnsim-faultsAware=%IS FAULT AWARE%,deleteNContacts=%NUMBER OF DELETED CONTACTS%-#%RUN NUMBER%.sca

The varriable parts in string are marked with %%. They are:
    -> %IS FAULT AWARE%
    -> %NUMBER OF DELETED CONTACTS%
    -> %RUN NUMBER%

OUTPUT:

"%s/METRIC=%s-FAULTAWARE=%s-MAX_DELETED_CONTACTS=%d-.txt"%(OUTPUT_PATH,metric[0],aware,MAX_DELETED_CONTACTS)

'''


#Received packet after a random atack, deleted contact/ number of contact
import sqlite3
import matplotlib.pyplot as plt
from functools import reduce
import sys
import os
import statistics
from brufn.utils import getListFromFile

#[(metric, x-axis label)]
METRICS = [("appBundleReceived:count","Delivered Bundles"),("deliveryRatio","Delivery Ratio"), ("dtnBundleSentToCom:count","Transmitted bundles"), ("appBundleReceivedDelay:mean","Mean Delay per Bundle"), ("appBundleReceivedHops:mean","Mean Hops per Bundle"), ("sdrBundleStored:timeavg", "Mean Bundles in SDR"), ('EnergyEfficiency', 'Energy Efficiency')]
def main(exp_path, net, routing_algotithm, num_of_reps):
        ra_dir = os.path.join(exp_path, net, routing_algotithm)
        for metric in METRICS:
                graph_output_dir = os.path.join(ra_dir, 'metrics')
                os.makedirs(graph_output_dir, exist_ok=True)
                cmp_graph_data = []
                for aware in [str(routing_algotithm == 'cgr-fa').lower()]:
                    # if not os.path.isdir(os.path.join(ra_dir, 'results')):
                    #     print(f"Not folder {os.path.join(ra_dir, 'results')}")
                    #     text_file = open(f"{graph_output_dir}/METRIC={metric[0]}.txt", "w")
                    #     text_file.write(str([(pf,0) for pf in [i/100 for i in range(0,110,10)]]))
                    #     text_file.close()
                    #     continue
            
                    path = os.path.join(ra_dir, 'results', "dtnsim-faultsAware=%s"%(aware))
                    print(path)
                    if(metric[0] == "deliveryRatio"):
                        f_avg_by_rep = receivedPacketAv2(path, num_of_reps)
                    elif( (metric[0] == "appBundleReceivedDelay:mean") or (metric[0] == "appBundleReceivedHops:mean") or (metric[0] == "sdrBundleStored:timeavg")):
                        f_avg_by_rep = receivedPacketAv3(path, num_of_reps, metric[0])
                    elif metric[0]=='EnergyEfficiency':
                        f_delivered_bundles =  getListFromFile(f"{graph_output_dir}/METRIC=appBundleReceived:count.txt")
                        f_number_of_transmisions = getListFromFile(f"{graph_output_dir}/METRIC=dtnBundleSentToCom:count.txt")
                        f_avg_by_rep = [(f_delivered_bundles[i][0], f_delivered_bundles[i][1] / f_number_of_transmisions[i][1] if f_number_of_transmisions[i][1] != 0 else 0) for i in range(len(f_delivered_bundles))]
                    else:
                        #compute average function for all repetitions of a contact plan (one contac plan average- CONTACT PLAN AVERAGE)
                        f_avg_by_rep = receivedPacketAv(path, num_of_reps, metric[0])

                    #compute average function for all contact plans (all contact plans average - DENSITY AVERAGE)
                    graph_data = f_avg_by_rep
                    cmp_graph_data.append(graph_data)

                    # save function
                    text_file = open(f"{graph_output_dir}/METRIC={metric[0]}.txt", "w")
                    text_file.write(str(graph_data))
                    text_file.close()

#Tengo que calcular para un contact plan para todas las repeticiones
def receivedPacketAv(input_path, amount_of_repetitions, metric):
    graph_data = []
    for d in ["%1.1f"%(x/10.) for x in range(11)]:
      if d=='0.0': 
        d='0'
      elif d=='1.0': 
        d='1'
      received_packet = 0
      for i in range(amount_of_repetitions):
          # Connect to database
          print("%s,failureProbability=%s-#%d.sca" % (input_path, d, i))
          conn = sqlite3.connect("%s,failureProbability=%s-#%d.sca" % (input_path, d, i))
          conn.row_factory = sqlite3.Row
          cur = conn.cursor()

          # execute sql query to get bundles received by all nodes
          cur.execute("SELECT SUM(scalarValue) AS result FROM scalar WHERE scalarName='%s'"%(metric))
          rows0 = cur.fetchall()
          received_packet += 0 if (rows0[0]["result"] == None) else rows0[0]["result"]

      cur.execute("SELECT MAX(scalarValue) AS result FROM scalar WHERE scalarName='contactsNumber:sum'")
      rows0 = cur.fetchall()
      contact_number = rows0[0]["result"]

      graph_data.append((float(d),received_packet / float(amount_of_repetitions)))

    return  graph_data

#Tengo que calcular para un contact plan para todas las repeticiones
def receivedPacketAv2(input_path, amount_of_repetitions):
    graph_data = []
    for d in ["%1.1f"%(x/10.) for x in range(11)]:
      if d=='0.0': 
        d='0'
      elif d=='1.0': 
        d='1'  
      received_packet = 0
      for i in range(amount_of_repetitions):
          # Connect to database
          print("%s,failureProbability=%s-#%d.sca" % (input_path, d, i))
          conn = sqlite3.connect("%s,failureProbability=%s-#%d.sca" % (input_path, d, i))
          conn.row_factory = sqlite3.Row
          cur = conn.cursor()

          # execute sql query to get bundles received by all nodes
          cur.execute("SELECT SUM(scalarValue) AS result FROM scalar WHERE scalarName='%s'"%("appBundleReceived:count"))
          rows0 = cur.fetchall()
          rx_packet = 0 if (rows0[0]["result"] == None) else rows0[0]["result"]

          cur.execute("SELECT SUM(scalarValue) AS result FROM scalar WHERE scalarName='%s'"%("appBundleSent:count"))
          rows1 = cur.fetchall()
          tx_packet = 0 if (rows1[0]["result"] == None) else rows1[0]["result"]
          received_packet += float(rx_packet) / float(tx_packet) if float(tx_packet)  != 0 else 0

      cur.execute("SELECT MAX(scalarValue) AS result FROM scalar WHERE scalarName='contactsNumber:sum'")
      rows0 = cur.fetchall()
      contact_number = rows0[0]["result"]

      graph_data.append((float(d),received_packet / float(amount_of_repetitions)))

    return  graph_data

def receivedPacketAv3(input_path, amount_of_repetitions,metric):
    graph_data = []
    for d in ["%1.1f"%(x/10.) for x in range(11)]:
      if d=='0.0': 
        d='0'
      elif d=='1.0': 
        d='1'      
      received_packet = 0
      for i in range(amount_of_repetitions):
          # Connect to database
          print("%s,failureProbability=%s-#%d.sca" % (input_path, d, i))
          conn = sqlite3.connect("%s,failureProbability=%s-#%d.sca" % (input_path, d, i))
          conn.row_factory = sqlite3.Row
          cur = conn.cursor()

          # execute sql query to get bundles received by all nodes
          cur.execute("SELECT AVG(scalarValue) AS result FROM scalar WHERE scalarName='%s'"%(metric))
          rows0 = cur.fetchall()
          received_packet += 0 if (rows0[0]["result"] == None) else rows0[0]["result"]

      cur.execute("SELECT MAX(scalarValue) AS result FROM scalar WHERE scalarName='contactsNumber:sum'")
      rows0 = cur.fetchall()
      contact_number = rows0[0]["result"]

      graph_data.append((float(d),received_packet / float(amount_of_repetitions)))

    return  graph_data

'''
Given a list of list of pairs: [[(x0,y0),...] , [(xn,yn),....]]
returns a unique list compute as average of above functions
'''
def promList(llist):
  assert len(llist) == len(CP_RANGE), "error amount of contact plans"
  assert len(list(filter(lambda l: len(l) != len([x/10 for x in range(11)]), llist))) == 0, "error failure probability"

  llist = [list(map(lambda f: f[x], llist)) for x in range(len([x/10 for x in range(11)]))]
  llist = list(map(lambda l: (reduce(lambda x,y: (x[0] + y[0],x[1] + y[1]),l), statistics.stdev([t[1] for t in l])), llist))
  return [(x[0][0]/float(len(CP_RANGE)), x[0][1]/float(len(CP_RANGE)), x[1]) for x in llist]


if __name__ == "__main__":
    if len(sys.argv) == 5:
        '''
            sys.argv[1] -> Experiment path
            sys.argv[2] -> net
            sys.argv[3] -> routing_algotithm
            sys.argv[4] -> num_of_reps
            
        '''

        main(sys.argv[1], sys.argv[2], sys.argv[3], int(sys.argv[4]))
    else:
        exit(-1)

